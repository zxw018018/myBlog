# sumo logic
## [Implement_strStr()](#implement-strstr)


### Implement strStr()
```java
class Solution {
    public int strStr(String haystack, String needle) {
        int haystackLen = haystack.length();
        int needleLen = needle.length();
        if (needleLen == 0) return 0;
        for (int i = 0; i < haystackLen - needleLen + 1; i++) {
            int haystackIndex = i;
            int needleIndex = 0;
            while (haystackIndex < haystackLen && needleIndex < needleLen && haystack.charAt(haystackIndex) == needle.charAt(needleIndex)) {
                haystackIndex++;
                needleIndex++;
            }
            if (needleIndex == needleLen) return i;
        }
        return -1;
            
    }
}
```

### Find all permutation needle in haystack
```java
public List<String> findPermutation(String needle, String haystack) {
    List<String> res = new ArrayList<>();
    List<Integer> indices = new ArrayList<>();
    int N = needle.length();
    int H = haystack.length();
    char[] countN = new char[MAX];
    char[] countH = new char[MAX];
    for (int i = 0; i < N; i++) {
        countN[needle.charAt(i)]++;
        countH[haystack.charAt(i)]++;
    }

    for (int i = N; i < H; i++) {
        if (compare(countN, countH))
            res.add(haystack.substring(i-N, i));

        countH[haystack.charAt(i)]++;
        countH[haystack.charAt(i-N)]--;
    }

    if (compare(countN, countH))
        res.add(haystack.substring(H-N, H));

    return res;


}

private int MAX = 256;

public boolean compare(char[] arr1, char[] arr2) {
    for (int i = 0; i < MAX; i++)
        if (arr1[i] != arr2[i])
            return false;
    return true;
}
```

### Lowest Common Ancestor of a Binary Tree
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == q || root == p) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) return root;
        else if (left != null) return left;
        else return right;
    }
}
```

### Lowest Common Ancestor of a Binary Search Tree
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (Math.max(p.val, q.val) < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (Math.min(p.val, q.val) > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else 
            return root;
    }
}
```

### Group Anagrams
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> group = new HashMap<>();
        for (String s: strs) {
            char[] tmp = s.toCharArray();
            Arrays.sort(tmp);
            String key = new String(tmp);
            if (!group.containsKey(key)) {
                group.put(key, new ArrayList<>());
            }
            group.get(key).add(s);
        }
        
        List<List<String>> res = new ArrayList<>(group.values());
        return res;
    }
}
```

### Decode Ways
```java
class Solution {
    public int numDecodings(String s) {
        if (s.isEmpty()) return 0;
        int prev = 1;
        int cur = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 1; i < s.length(); i++) {
            int tmp = cur;
            cur = s.charAt(i) == '0' ? 0 : cur;
            if (s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2' && s.charAt(i) <= '6')
                cur += prev;
            prev = tmp;
            
        }
        return cur;
    }
}
```

### Decode Ways II
```java
class Solution {
    public int numDecodings(String s) {
        if (s.isEmpty()) return 0;
        long M = 1000000007;
        long prev = 1;
        long cur = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;
        for (int i = 1; i < s.length(); i++) {
            long tmp = cur;
            if (s.charAt(i) == '*') {
                cur = 9 * cur;
                if (s.charAt(i-1) == '1') {
                    cur = (cur + 9 * prev) % M;
                } else if (s.charAt(i-1) == '2') {
                    cur = (cur + 6 * prev) % M;
                } else if (s.charAt(i-1) == '*') {
                    cur = (cur + 15 * prev) % M;
                }
            } else {
                cur = s.charAt(i) == '0' ? 0 : cur;
                if (s.charAt(i-1) == '1') {
                    cur = (cur + prev) % M;
                } else if (s.charAt(i-1) == '2' && s.charAt(i) <= '6') {
                    cur = (cur + prev) % M;
                } else if (s.charAt(i-1) == '*') {
                    cur = (cur + (s.charAt(i) <= '6' ? 2 : 1) * prev) % M;
                }
            }
            prev = tmp;
        }
        return (int) cur;
    }
}
```

### Simplify path
```java
class Solution {
    public String simplifyPath(String path) {
        Deque<String> deque = new LinkedList<>();
        for (String s : path.split("/")) {
            if (s.equals(".."))
                deque.pollFirst();
            else if (!s.equals("") && !s.equals("."))
                deque.addFirst(s);
        }
        
        StringBuilder sb = new StringBuilder();
        if (deque.isEmpty())
            sb.append("/");
        while (!deque.isEmpty())
            sb.append("/").append(deque.pollLast());
        return sb.toString();
    }
}
```
### find longest palindrome in string
```java
class Solution {
    private int low = 0;
    private int maxLen = 0;
    
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) return s;
        
        for (int i = 0; i < len - 1; i++) {
            extendPalindrome(s, i, i);
            extendPalindrome(s, i, i+1);
        }
        
        return s.substring(low, low + maxLen);
    }
    
    private void extendPalindrome(String s, int start, int end) {
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }
        
        if (maxLen < end - start - 1) {
            maxLen = end - start - 1;
            low = start + 1;
        }
    }
    
}
```

### Design circular queue using array
```java
class MyCircularQueue {
    int[] a;
    int front, rear = -1, length = 0;

    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        a = new int[k];
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if (isFull()) return false;
        else {
            rear = (rear + 1) % a.length;
            a[rear] = value;
            length++;
            return true;
        }
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if (isEmpty()) return false;
        else {
            front = (front + 1) % a.length;
            length--;
            return true;
        }
    }
    
    /** Get the front item from the queue. */
    public int Front() {
        return isEmpty()? -1: a[front];
    }
    
    /** Get the last item from the queue. */
    public int Rear() {
        return isEmpty()? -1: a[rear];
    }
    
    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        return length == 0;
    }
    
    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        return length == a.length;
    }
}
```

### Word search
```java
class Solution {
    private int m;
    private int n;
    
    public boolean exist(char[][] board, String word) {
        m = board.length;
        if (m == 0) return false;
        n = board[0].length;
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (search(board, word, 0, r, c)) return true;
            }
        }
        return false;
    }
    
    private boolean search(char[][] board, String word, int index, int r, int c) {
        if (r < 0 || r >= m || c < 0 || c >= n || word.charAt(index) != board[r][c]) return false;
        if (index == word.length() - 1) return true;
        char cur = board[r][c];
        board[r][c] = '.';
        boolean found = search(board, word, index+1, r+1, c) ||
                        search(board, word, index+1, r-1, c) ||
                        search(board, word, index+1, r, c+1) ||
                        search(board, word, index+1, r, c-1);
        board[r][c] = cur;
        return found;
    }
}
```

### Find peak value
```java
class Solution {
    public int findPeakElement(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int mid = (low + high) / 2;
            if (nums[mid] > nums[mid + 1])
                high = mid;
            else 
                low = mid + 1;
        }
        return low;
    }
}
```

### Find longest substring without repeating characters
```java
public static String findLongest(String s) {
    int maxLen = 0;
    int start = 0;
    HashMap<Character, Integer> map = new HashMap<>();
    for (int last = 0, first = 0; last < s.length(); last++) {
        if (map.containsKey(s.charAt(last))) {
            first = Math.max(first, map.get(s.charAt(last)) + 1);
        }
        map.put(s.charAt(last), last);
        if (last - first + 1 > maxLen) {
            start = first;
            maxLen = last - first + 1;
        }
    }
    return s.substring(start, start + maxLen);
}
```

### Min stack
```java
class MinStack {
    Stack<Integer> stack;
    Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int x) {
        stack.push(x);
        int minVal = minStack.isEmpty() ? x : Math.min(x, getMin());
        minStack.push(minVal);
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```







