# sumo logic
## [Implement_strStr()](#implement-strstr)


### Implement strStr()
```java
class Solution {
    public int strStr(String haystack, String needle) {
        int haystackLen = haystack.length();
        int needleLen = needle.length();
        if (needleLen == 0) return 0;
        for (int i = 0; i < haystackLen - needleLen + 1; i++) {
            int haystackIndex = i;
            int needleIndex = 0;
            while (haystackIndex < haystackLen && needleIndex < needleLen && haystack.charAt(haystackIndex) == needle.charAt(needleIndex)) {
                haystackIndex++;
                needleIndex++;
            }
            if (needleIndex == needleLen) return i;
        }
        return -1;
            
    }
}
```

### Find all permutation needle in haystack
```java
public List<String> findPermutation(String needle, String haystack) {
    List<String> res = new ArrayList<>();
    List<Integer> indices = new ArrayList<>();
    int N = needle.length();
    int H = haystack.length();
    char[] countN = new char[MAX];
    char[] countH = new char[MAX];
    for (int i = 0; i < N; i++) {
        countN[needle.charAt(i)]++;
        countH[haystack.charAt(i)]++;
    }

    for (int i = N; i < H; i++) {
        if (compare(countN, countH))
            res.add(haystack.substring(i-N, i));

        countH[haystack.charAt(i)]++;
        countH[haystack.charAt(i-N)]--;
    }

    if (compare(countN, countH))
        res.add(haystack.substring(H-N, H));

    return res;


}

private int MAX = 256;

public boolean compare(char[] arr1, char[] arr2) {
    for (int i = 0; i < MAX; i++)
        if (arr1[i] != arr2[i])
            return false;
    return true;
}
```

### Lowest Common Ancestor of a Binary Tree
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == q || root == p) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) return root;
        else if (left != null) return left;
        else return right;
    }
}
```

### Lowest Common Ancestor of a Binary Search Tree
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (Math.max(p.val, q.val) < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (Math.min(p.val, q.val) > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else 
            return root;
    }
}
```

### Group Anagrams
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> group = new HashMap<>();
        for (String s: strs) {
            char[] tmp = s.toCharArray();
            Arrays.sort(tmp);
            String key = new String(tmp);
            if (!group.containsKey(key)) {
                group.put(key, new ArrayList<>());
            }
            group.get(key).add(s);
        }
        
        List<List<String>> res = new ArrayList<>(group.values());
        return res;
    }
}
```

### Decode Ways
```java
class Solution {
    public int numDecodings(String s) {
        if (s.isEmpty()) return 0;
        int prev = 1;
        int cur = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 1; i < s.length(); i++) {
            int tmp = cur;
            cur = s.charAt(i) == '0' ? 0 : cur;
            if (s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2' && s.charAt(i) <= '6')
                cur += prev;
            prev = tmp;
            
        }
        return cur;
    }
}
```

### Decode Ways II
```java
class Solution {
    public int numDecodings(String s) {
        if (s.isEmpty()) return 0;
        long M = 1000000007;
        long prev = 1;
        long cur = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;
        for (int i = 1; i < s.length(); i++) {
            long tmp = cur;
            if (s.charAt(i) == '*') {
                cur = 9 * cur;
                if (s.charAt(i-1) == '1') {
                    cur = (cur + 9 * prev) % M;
                } else if (s.charAt(i-1) == '2') {
                    cur = (cur + 6 * prev) % M;
                } else if (s.charAt(i-1) == '*') {
                    cur = (cur + 15 * prev) % M;
                }
            } else {
                cur = s.charAt(i) == '0' ? 0 : cur;
                if (s.charAt(i-1) == '1') {
                    cur = (cur + prev) % M;
                } else if (s.charAt(i-1) == '2' && s.charAt(i) <= '6') {
                    cur = (cur + prev) % M;
                } else if (s.charAt(i-1) == '*') {
                    cur = (cur + (s.charAt(i) <= '6' ? 2 : 1) * prev) % M;
                }
            }
            prev = tmp;
        }
        return (int) cur;
    }
}
```

### path

### find longest palindrome in string

### circular queue using array










